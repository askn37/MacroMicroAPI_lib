# SRAM_persistent.ino

このサンプルスケッチは以下について記述している；

- SRAMによる擬似不揮発メモリ（Pseudo Non-Volatile Memory）

## 対象AVR

- megaAVR世代
  - megaAVR-0系統
  - tinyAVR-0/1/2系統
- modernAVR世代
  - AVR Dx系統

## 初期化されないSRAM領域の確保

通常、関数の外で宣言されたSRAM領域（`".data"`セクション）は必ず
電源投入あるいはリセット起動後に定数初期化またはゼロ初期化が為される。
宣言はされたもののコード中のどこからも
参照されていない領域は初期化されないが、
それらは普通コンパイル後のリンク結合処理に拠って（場合によっては未使用警告と共に）除去されるから、
通常の用法では未初期化変数に遭遇することはない。

しかしながら明示的に`".noinit"`セクションに領域配置すると、
真に初期化されていない変数を確保し、参照することが出来る。

```c
static uint8_t volatile_values[MAX_SIZE] __attribute__ ((section (".noinit")));

struct {
  uint32_t reset_count;
  char save_string[26];
  uint16_t crc16;
} save_structure __attribute__ ((section (".noinit")));
```

初期化されていないわけだから当然その内容は全くの不定である。
概ねランダムな値が観測されるが、それは以前その領域を使っていた
コードの断片や残骸（例えばブートローダーの作業情報）であったりする。
だがデータ領域は物理的にはSRAMなので通電している限り以前の最後の状態を、
リセットしてもなお変化させることなく保持し続けている __可能性__ がある。
この性質を利用して擬似的な不揮発メモリを実装せしめるのが本稿の要件だ。

> ARM系列のMCUでは休止形態によって
SRAM/DRAM領域への電源供給も断てるため必ずしも当てはまらないが、
8bit系AVRではすべての品種で、通電維持している限り SRAM内容の維持が期待される。

## 破壊検査

確保された領域変数は当然初期値不定であるから、使用するにはまず初期化しなければならない。
しかし毎回おなじ定数で初期化すると疑似不揮発メモリとはならないので、
その内容が破壊されている場合に限って初期化するように配慮する。
単純な未初期化判定にはマジックナンバーが使えるし、
破壊検査にはチェックサムやCRC検査符号が利用できる。

```c
/* 以下のヘッダで宣言されているショートカットマクロ属性 */
/* #include <api/macro_api.h> */
#define NIMEM __attribute__ ((section (".noinit")))

/* crc16関数は以下のヘッダで宣言されている */
#include <api/btools.h>

/* 構造体変数の準備 */
struct {
  uint32_t reset_count;
  char save_string[26];
  /* ワードアライメント境界に注意 */
  uint16_t crc16;
} persistent_save NIMEM;

/* CRC16での破壊検査 */
/* 検査結果がゼロなら非破壊 */
if (crc16(&persistent_save, sizeof(persistent_save)) != 0) {
  /* 初期化作業 */
  persistent_save.reset_count = 0;
  strcpy((char*)&persistent_save.save_string, __DATE__ " " __TIME__);
}

/* その他の変数更新処理... */
persistent_save.reset_count++;

/* CRC検査符号更新 */
/* 末尾以外を検査した結果を、末尾に書き出す */
persistent_save.crc16 = crc16(&persistent_save,
  sizeof(persistent_save) - sizeof(persistent_save.crc16));
```

検査対象が十分小さいなら検査符号はチェックサム（排他的論理和または単純加算）でも良いが検査精度は低い。
複数のビットが同時に化けた場合の検出精度は相対的に低下するので、
8bitチェックサムが概ね信用できるのは 20byte程度までである。

> 故に単純なチェックサム検査は、再送可能な通信ペイロード検査用途以外ではあまり使われなくなっている。
例えば対象の全領域が 0xFFで埋め尽くされている場合、
補数で補わない単純排他的論理和チェックサムでは偶数バイトサイズで、
単純加算チェックサムでは257バイトの倍数サイズで、正常と判定される確率が高いだろう。
つまり特定のビットパターンが対象になると信頼性が著しく低下する。

8bit CRC符号の場合、十分信用できるのは 256bit（32byte）までであるから
多くの場合これでは不足気味である。
よって 65536bit（8192byte）までは十分信用できる 16bit CRC符号を選択するのが妥当だろう。
これを超える領域の場合は 32bit CRC符号を選択することになるが、
スペース効率も算出速度も低いので 8bit CPUの世界ではいささか荷が重い。

> 当然のことながら変数内容変更〜CRC符号更新のあいだはクリティカルセクションで、
その間に CPUがリセットされてしまうと不整合が生じてしまう。
この問題を避けるには正副ふたつの領域を確保し、
片方は常に正規化された状態を保つように配慮するのが常道だ。

## 疑似不揮発メモリの要点

SRAMを使った疑似不揮発メモリの欠点は電源を切ると消失してしまうことだが、
最大の長所は真の不揮発メモリ（NVM）である EEPROMや FLASHメモリと違って
書換可能耐久限界が存在しないことだ。
不揮発メモリは概ね1万〜10万回の書換・消去を超えると設計上の製品寿命に達し、
遂には信用できなくなってしまう。
そして1万回程度の書換は、数秒毎に保持データを更新しなければならないような用途だと
数日〜数週間ですぐに到達してしまう程度の回数である。

### クリティカルセクションの障害検出

作業途中に不意のリセットや電源断が発生した場合、
その中断した作業が以後の動作を不正にするような
クリティカルセクションを持つ応用では
その障害原因に応じてリセット起動後に
障害回復を行いたいだろう。

- クリティカルセクションに入る前に、作業開始マークを不揮発領域に保存
- 作業完了後に不揮発領域の従前のマークを削除
  - リセット起動時に従前のマークが残っていれば障害発生が判明する

このような進捗管理を（正規の）不揮発メモリで行うと
書換可能回数の上限からそれ自体が障害原因となりかねない。
これを擬似不揮発メモリ（SRAM）で代替するのは理にかなう。

### 不揮発メモリ（NVM）更新のバックアップ

不揮発メモリ（NVM）の正常な書換には十分な電力供給が必要だ。
それであってなお書換作業は数十ミリ秒を要すクリティカルセクションである。
その間に電源断が発生することは普通にありえるので多重保護は必要だろう。
しかし限られた記憶容量で二重化するのが困難であるなら
その一方を疑似不揮発メモリ（SRAM）で肩代わりするのは有益である。

- NVMからSRAMに複製：NVMは不変
- SRAMを更新：NVMは不変
- SRAMからNVMを書換：NVMは破壊中だがSRAMは正常
  - ここで中断リセットが発生してもSRAMが無事なら NVMの書換再試行が出来る

ページ単位での更新しかできない NVM書換にはどのみち RAMバッファが必要なので
これを疑似不揮発メモリに置き換えるのは、僅かな改修で済むため導入する価値が高い。

### 通信セッションの維持管理

ある種のセンサーノードに置いて
セキュアな通信セッションの再認証処理が重くて処理コストが高い場合、
電源断からの初期化回復はやむを得ないにしても
単純なリセット回復からの再認証は避けたい場合がある。
処理コストが重い＝実行中に再度障害を繰り返して無限ループに陥る可能性が高いからだ。
これは自身のセンサーノード障害だけでは済まず、
リモート先のサーバにも無意味な高負荷をかけて連鎖障害に至る可能性が高い。
同時運用するセンサーノード数が膨大な数になると、サービス提供側からすればこれは全く看過できない。

この問題を緩和すべくセキュア通信セッションを維持継続するための
トークン管理を不揮発メモリで行いたいことだろう。
トークンが有効な限り再認証を省略できるのであれば
通信負荷もサーバ負荷も節約できるからだ。

ところがこれがワンタイムトークン形式で
通信毎に更新・改定してサーバとの同期を維持する仕様においては、
このトークンを不揮発メモリに毎回格納するのは全く得策ではない。
数秒〜数分毎に通信が発生するセンサーノードでは
わずか数日〜数週間で不揮発メモリ寿命問題に直面してしまう。
この種の実装で疑似不揮発メモリを活用するのは良い対策になるだろう。

> 実際に LoRaWAN通信ではこの種のセッション同期維持管理を仕様として要求される。
不揮発メモリ維持をしない場合、リセットも電源断も容易でない運用管理を強要されてしまう。

### 疑似乱数エントロピープール

擬似乱数のエントロピープールがリセット起動毎に毎回同一値で初期化されるような場合、
これは毎回同一の疑似乱数系列を生成することになる。
それが好ましくない場合はリセット起動毎に異なるエントロピープールを与えなければならないが
ハードウェア乱数発生源を持たない MCUの場合、これはかなり難しい。
そもそも信頼できるハードウェア乱数発生源を持たないから
疑似乱数で代替せねばならない状況だろうからだ。

よくある実装では ADCを使って未使用外部ポートをスキャンし、外乱ノイズを取り込むものがある。
しかしこれは電気的に安定している優れたハードウェア設計であるほど乱数の偏りが減じ、
同一の安定した乱数系列になってしまう可能性が高くなる。

> 無線機器ノードでは外部アンテナの RSSIを測定して
エントロピープールを生成する実装が見られるが、これもまた同様の問題を隠し持っている。
普段は気づきにくいが、技適試験段階になって静粛な電波暗室に持ち込んだときに発覚することもあるだろう。

そこでリセット前のエントロピープールを擬似不揮発メモリで引き続き使う実装を考えることが出来る。
リセット前の系列を維持することも可能だが破壊検査は必須ではなく、
むしろそれを利用して疑似乱数系列自体を切り替えてしまうことも可能だ。

### 制約

応用プログラムの他に ブートローダーが存在してかつそれが先行して実行される場合、
SRAMの一部はワーク領域として使用され、書き換えられる。
これが擬似不揮発領域と重なっている場合は内容が破壊されることになるので
期待した結果とならないだろう。

またリセット時の電磁ノイズや突入電流等のサージによって、
SRAM内容は不規則に変化しうる。
動作電圧低下を含む BOD等によるリセット期間延長された場合も同様である。
容量に余裕があるなら信頼性を向上すべく、疑似不揮発領域は二重化すべきだろう。

## 著作表示

Twitter: [@askn37](https://twitter.com/askn37) \
GitHub: [https://github.com/askn37/](https://github.com/askn37/) \
Product: [https://askn37.github.io/](https://askn37.github.io/)

Copyright (c) askn (K.Sato) multix.jp \
Released under the MIT license \
[https://opensource.org/licenses/mit-license.php](https://opensource.org/licenses/mit-license.php) \
[https://www.oshwa.org/](https://www.oshwa.org/)
